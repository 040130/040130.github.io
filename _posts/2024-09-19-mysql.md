---
title: mysql
date: 2019-09-19
layout: post
---


### 数据库和sql

#### 1、数据库的分类有哪些



#### 2、sql语句的分类



#### 3、列举mysql常用的数据类型



#### 4、 说说 drop、truncate 和 delete 的区别



### DQL 基本查询

#### 1、sql 中如何给字段取别名（有几种方式，分别在什么场景下使用？）

- 在 sql 语句中，使用 as 关键字 给表、字段、查询结果取别名
- 在简单的查询语句中，as 关键字可以省略不写
- 在复杂查询语句中，建议不要省略 as 关键字，这样可读性会更好

#### 2、distinct 关键字的作用是什么

（如何使用，需要注意什么）

- distinct 关键字的作用是在查询中去除重复的数据
- 该关键字使用在指定的字段前面
- 需要注意的是，使用 distinct 关键字的字段要紧跟在 select 关键字后面

#### 3、where 子句中常见的运算符有哪些

where 子句是用来做条件筛选的
where 子句中可以使用的运算符包括：

  - 比较运算符，例如：>  <  =  <= ...
  - 逻辑运算符，例如 and(并且运算)， or(或运算)， not(取反运算)
  - 其它特殊的运算符:between(在指定区间取值),in(符合一组数据中的一个即可),is null(返回null数据)

#### 4、like 模糊查询用法

like模糊查询中有两个关键的字符,分别是%和_
%用来做模糊，可以匹配任意个字符
如果我们想要精准匹配,可以使用_,一个_匹配一个字符

#### 5、列举聚合函数

常用的聚合函数有5个
求最大值、最小值、求和、求平均值的聚合函数分别是:MAX,MIN,SUM,AVG
用count时,如果用的是*,会统计出null值的数据行数量,如果用的是指定的字段名称,null数据行不会统计

#### 6、having 和 where 的区别

having 和 where 都是用来做条件筛选的
不同的是:

  - where是对所有的记录进行筛选,having是对分组后的记录进行筛选
  - where不能放在group by子句后面
  - having是固定和roup by一起使用,放在group by后面,作用相当于 where
  - where后面不能使用聚合函数,having 可以

#### 7、mysql 中如何实现分页查询

在mysql中使用limit关键字实现分页查询
limit关键字后面可以跟2个参数,第一个参数表示起始的索引值,第二个参数表示查询的每页记录数
limit后面也可以只跟一个参数,此时该参数指的是所有记录中的前n条记录(也可以理解位第一页的数据)
mysq8.0以后新增了一个分页语法,是limit 记录数 offset 起始索引

#### 8、order by 和 group by 的区别

- 这两个子句在sql语法中的作用不一样
- order by指的是排序查询,可以根据一个字段或多个字段排序,默认asc升序,我们也可以指定降序排序,使用desc关键字
- group by的作用是分组查询,可以根据一个字段或多个字段进行分组查询,需要注意的是查询的结果只能是分组的列和聚合函数,可以使用 having关键字筛选分组后的数据



### SQL函数

#### 1、sql 中如何处理 null 值

在sql中我们可以使用coalesce函数和ifnull函数
这两个函数都可以接收两个参数,第一个参数不为null,返回第一个参数,为null则返回第二个参数

#### 2、说说 if 和 case 函数的用法

这两个都是流程控制函数
if函数接收三个参数,第一个参数是表达式,如果表达成立,则该函数返回第二个参数值,如果不成立则返回第三个参数值
case 函数有两种用方法

  - 第一种用于条件匹配,在when关键字后面指定条件,如果条件成立,则返回当前then的结果
  - 第二种用于精准匹配,这个时候是在case后面指定要匹配的值,和when后面的值进行比较,如果匹配上了,则返回当前then的结果
  - 这两种用法中,如果不满足条件或者精准拼配,都是返回esle后面的结果
    需要注意的是:要使用end关键字来结束case语法

#### 3、列举常用的函数

5个聚合函数
null值处理函数:COALESCE()和ifnull()
数学函数:floor(),RAND(),TRUNCATE()
字符串函数:trim(),substring(),concat(),lower(),UPPER()
日期函数:CURRENT_DATE(),NOW(),TIMESTAMPDIFF()
流程控制函数:if()

### 约束

#### 1、MySQL中如何设置主键自增

MySQL中通过将关键字 auto_increment 添加到要自增的字段声明上设置主键自增。
其设置auto_increment有以下条件：

1. 字段要求具有索引，一般我们是给主键添加，而主键具有主键索引；

2. 要求字段的类型必须是数字类型，包括整数和浮点数；

3. 在一张表中只能有一个主键自增列存在。

#### 2、数据库的约束有哪些

数据库中常见的约束有6个:

1. 主键约束(primary key):表示当前的字段是数据的唯一标识符,唯一且不能为空,例如:表中id字段

2. 外键约束(foreign key):用来让两张表的数据之间建立连接,保证数据的一致性和完整性(当前表的外键是另一张表的主键)
   例如:员工表中设置部门编号为外键,可以关联部门表

3. 非空约束(not null):限制当前字段的数据不能为 null,例如:我们可以给员工的姓名字段添加非空约束,姓名不能为空

4. 唯一约束(unique):保证该字段的所有数据都是唯一、不重复,可以为null,例如:给员工的身份证号码字段添加唯一约束

5. 检查约束(check):保证字段的值满足某一个,或者某个区间,例如:性别字段可以设置检查约束,限制当前字段只能输入'男'或'女'

6. 默认值约束(default):保存数据时,如果没有指定该字段的值,则采用默认值,例如:员工的岗位字段,插入数据时,不指定岗位,默认为'员工'



### 连接查询

#### 1、内连接和外连接的区别以及应用场景

内连接和外连接都是用来多表连接查询的:内连接使用inner join实现,外连接使用left join或者right join实现的
内连接是返回所有满足连接条件的数据行,而外连接是返回主表的所有数据和副表中满足条件的数据行,不满足条件的使用null值连接
例如:

  - 查询所有的员工信息和员工的部门信息,应该使用外连接,查询所有的员工,包括没有部门的员工信息
  - 查询所有有部门的员工信息,应该使用内连接,只返回有部门的员工信息

#### 2、连接查询中，`ON`子句和`WHERE`子句的作用有何区别？

- ON子句:用于指定表之间的连接条件,在表连接时就过滤不满足条件的行(主要影响连接结果)
- WHERE子句:在表连接完成后,对连接产生的结果集进行过滤(影响最终返回的行)
- 注意:外连接中,ON不会过滤基准表的行,而WHERE可能会过滤掉基准表中不满足条件的行(即使ON中已匹配)



### 视图

#### 1、什么是视图，说一说视图的作用？

视图是由查询语句定义的虚拟表,本身不存储数据,数据来源于表,使用 view 关键字创建
它的作用主要有:
（1）简化复杂查询:封装常用的查询逻辑,使sql更易理解和维护
（2）数据安全:通过视图控制用户对敏感数据的访问权限
（3）逻辑隔离:通过基表创建的多个视图,逻辑是相互隔离

#### 2、通过视图更新基表要满足什么条件？

1. 视图定义中只包含一个基表

2. 视图中包含基表的主键或唯一键

3. 视图中没有包含聚合函数和distinct关键字

4. 视图的定义中不能包含表达式或者子查询

#### 3、视图和表的区别是什么

- 存储方式:视图是虚拟表,不存储数据,基表是存储实际数据的
- 空间占用:视图仅仅占用定义的空间,表占用物理存储空间
- 更新操作:视图更新基表有限制,表可以直接更新

#### 4、查询视图和查询基表，谁的效率高，为什么？

查询基表的效率高

- 视图相当于一个中间商,查询视图本质是通过是视图查询基表,效率没有直接查询基表的效率高
  因为视图不存储数据,每次查询视图时,都需要执行视图定义中的select语句
  动态生成结果,而直接查询基表可以直接读取存储的数据,减少计算开销

#### 5、哪些情况下，视图法直接执行 INSERT、UPDATE 或 DELETE 操作？至少列举 3 种 

1. 视图定义中使用了distinct或者聚合函数

2. 视图的查询中使用了多表连接(join)

3. 视图的定义中,字段包含表达式计算(例如 sal*1.2)

#### 6、某电商系统需要频繁查询 “近 30 天已付款的订单及对应商品名称”，这个场景是否适合用视图？为什么？ 

适合
原因:使用的目的是为了简化查询语句
当前的业务中:近30天已付款的查询条件是固定的,查询订单及对应商品名称也是固定,
也就是说这个复杂查询的sql语句不会变化,所以适合使用视图来优化



### 存储过程

#### 1、什么是存储过程、存储过程优缺点？

存储过程是一组预编译的sql语句集合,存储在数据库中,通过名称和参数重复调用,使用procedure关键字声明

- 优点

  1. 存储过程是预编译的代码块,执行效率高

  2. 存储过程在服务器端运行,减少客户端压力

  3. 存储过程只需要创建一次,可以重复使用

  4. 存储过程代替大量的sql语句,提高通信速率

  5. 可以一定程度上确保数据安全

- 缺点

  1. 调试麻烦

  2. 可移植性低

#### 3、说一下存储过程的参数类型

存储过程的参数有三种类型

1. in类型的参数:表示入参,在存储过程中,不能修改

2. out类型的参数:表示出参,在存储过程中可以重新赋值,在调用存储过程时可以获取该结果

3. inout:既是入参,也是出参,具备入参和出参的特点

#### 4、说一说系统变量、用户变量和局部变量的作用

- 系统变量:是控制数据库特定行为的参数,这些变量可以被设置为特定的值来改变服务器的默认设置
  比如说autocommit,这个系统变量可以设置提交事务的行为
- 用户变量和局部变量可以用来保存一些临时数据,例如:在存储过程中声明局部变量,接收sql操作的结果

#### 5、创建存储过程时，`BEGIN...END`块的作用是什么？如果存储过程只有一条 SQL 语句，是否可以省略？ 

BEGIN...END块的作用是包裹多条sql语句或者复杂的业务逻辑
可以省略

#### 6、 调用存储过程使用什么语句？若存储过程有 OUT 参数，如何获取其返回值？

使用call存储过程名称来调用
我们可以在存储过程外面声明一个用户变量,在调用存储过程是,使用该变量接收out参数

#### 7、MySQL 中能否直接修改存储过程的逻辑（如 SQL 语句）？若不能，如何实现 “修改” 效果？  

在8.0.16版本之前使用drop,create重新创建来修改存储过程的逻辑
在8.0.16版本之后可以使用alter关键字修改存储过程的逻辑,语法和创建的语法类似

#### 8、 为什么说存储过程可能增加数据库维护成本？请举例说明。 

可移植性不高,切换数据库,那么存储过程的语法可能需要重写
逻辑复杂不易维护

#### 9、某系统需要 “根据用户 ID 批量删除其所有订单及关联数据”，这个场景是否适合用存储过程？为什么？

适合
使用存储过程的目的是为了简化操作逻辑,提升执行效率,在当前的业务中
删除的逻辑复杂,且逻辑是一致的不会变化,所以适合使用存储过程

#### 10、 存储过程中能否使用事务控制语句（如`BEGIN TRANSACTION`、`COMMIT`）？请说明原因 

当然可以。在存储过程中，不仅可以，而且**强烈推荐**使用事务控制语句，这是存储过程处理复杂业务逻辑时确保数据一致性和完整性的核心手段。

原因：

1. **保证原子性 (核心目的)**：存储过程通常包含多个SQL操作。事务确保这些操作要么**全部成功**（`COMMIT`），要么**全部失败**（`ROLLBACK`），防止数据出现“一半成功一半失败”的不一致状态。
2. **维护数据完整性**：通过事务，可以确保复杂的业务规则（如A账户扣款和B账户加款必须同时成功）在存储过程中被完整执行，保持数据始终处于正确状态。
3. **实现错误处理**：事务控制语句（`BEGIN TRANSACTION`, `COMMIT`, `ROLLBACK`）与存储过程的错误处理机制（如 `TRY...CATCH`）是**标准搭配**。一旦发生错误，可以立即回滚所有更改。

### 游标

#### 1、什么是游标，说说它的作用

游标是数据库中用于逐行遍历查询结果集的数据库对象,可以在存储过程和存储函数中声明使用,声明游标的关键字是cursor
游标相当于一个集合,保存查询出来的一组数据,可以逐行遍历

#### 2、游标和普通 select 查询的核心区别是什么

select是依从性返回所有结果集
游标允许逐行访问结果集,适合需要对每行数据进行单独处理的场景

#### 3、使用游标的步骤

1. 声明游标:定义游标关联的查询结果集(declare 游标名称 cursor for 查询语句)
2. 声明not found异常处理器:标记玄幻遍历游标结束的条件
3. 打开游标:open 游标名称
4. 获取数据:fetch 游标名称 into 标量
5. 关闭游标:close 游标名称

#### 4、什么场景适合使用游标，什么场景不适合？

适合的场景:需要逐行处理结果集(例如:批量更新员工的部门,又比如根据条件修改员工的工资)
不适合的场景:结果集太大不合适使用游标(游标加载全部数据到内存,效率低),可以通过update/delete直接操作表



### 异常处理

#### 1、列举3种mysql常见异常

- 主键冲突:sqltate '23000',错误码 1062
- 除零异常:sqlstate '22012',错误码 1365
- 数据类型不匹配异常:sqlstate '22005',错误码 1366
- 游标遍历结束:not found 

#### 2、mysql 中异常的两种处理方式（exit和continue）的区别？分别适合什么场景

exit:捕获异常后,退出当前存储过程,适用于严重的错误.例如:主键冲突,事务失败
continue:捕获异常后,继续执行过程,适用于不影响后续逻辑的轻微错误,例如:游标结束



### 存储函数

#### 1、什么是存储函数？其核心特征是什么？ 

存储函数是预编译并存储在数据库中的SQL程序,必须返回一个值,可嵌入SQL语句(如SELECT)中调用,用于实现特定计算或查询逻辑
核心特征:强制返回值、仅支持IN参数、可嵌入SQL

#### 2、存储函数为什么必须有返回值？如何指定返回值类型？ 

存储函数本质是“计算工具”,需像数学函f(x)=y一样输出结果,因此必须通过RETURN语句返回值
通过CREATE FUNCTION中的RETURNS 数据类型(如RETURNS INT)指定返回值类型

#### 3、存储函数与存储过程在参数类型上有何区别？ 

存储函数仅支持IN类型参数(输入参数,默认隐含)
存储过程支持IN(输入)、OUT(输出)、INOUT(双向)三种参数类型。

#### 4、存储函数能否直接返回结果集（如`SELECT * FROM 表`）？为什么？ 

不能。
存储函数中的SELECT语句必须通过INTO子句将结果存入变量(如SELECT name INTO var FROM users)无法直接返回结果集
存储过程则可直接返回结果集

#### 5、什么场景适合使用存储函数？举一个实际业务例子。 

适合简单计算、数据转换或单行查询结果处理。
例如:创建calc_age(birth DATE)函数,根据出生日期计算年龄,可直接在SELECT中调用(SELECT name,calc_age(birth)FROM users）

#### 6、存储函数中如何主动抛出异常？请写出核心代码。 

使用`SIGNAL`语句。例如：参数非法时抛异常：  

```mysql
IF price < 0 THEN
SIGNAL SQLSTATE '45000' 
SET MESSAGE_TEXT = '价格不能为负数';
END IF;
```

#### 7、创建存储函数时，`DETERMINISTIC`特性的作用是什么？默认值是什么？ 

DETERMINISTIC表示函数输入相同参数时返回结果固定(如数学计算)帮助优化器缓存结果提升效率
默认值为NOT DETERMINISTIC(非确定性)



### 触发器

#### 1、什么是触发器？其“自动触发”的核心条件是什么？ 

触发器是与表关联的特殊程序,当表发生INSERT/UPDATE/DELETE操作时自动执行
核心条件:关联表发生指定触发事件(如INSERT),且满足触发时机(BEFORE/AFTER)

#### 2、触发器的`BEFORE`和`AFTER`触发时机有何本质区别？分别适用于什么场景？ 

BEFORE在操作执行前触发,可修改即将插入/更新的数据(如校验、自动计算字段)
AFTER在操作执行后触发,适合记录日志、同步数据(无法修改已提交数据)

#### 3、触发器中`NEW`和`OLD`关键字的作用是什么？分别在哪些触发事件中可用  

NEW.字段引用插入/更新后的新值(INSERT/UPDATE可用)
OLD.字段引用更新/删除前的旧值(UPDATE/DELETE可用)
例如:UPDATE触发器中,OLD.price是旧价格,NEW.price是新价格

#### 4、触发器能否修改自身关联表的数据？为什么？ 

不建议。
若触发器中修改自身关联表(如UPDATE触发器又UPDATE同表),可能导致递归触发(无限循环执行),引发性能问题或数据异常

#### 5、什么场景适合使用触发器？举一个实际业务例子。 

适合自动维护数据一致性、记录变更日志
例如:创建AFTER UPDATE触发器,当products表价格修改时,自动向price_logs表插入旧价格、新价格和修改时间

#### 6、触发器与存储过程的核心区别是什么？ 

触发器是“事件驱动自动执行”,无需手动调用,依附于表的操作
存储过程是“手动调用执行”,可独立存在,不依赖表事件

#### 7、如何查看某张表关联的所有触发器？ 

通过系统表查询：  

```mysql
SELECT * FROM information_schema.TRIGGERS 
WHERE EVENT_OBJECT_TABLE = '表名';
```





### 定时任务

#### 1、什么是MySQL事件（定时任务）？其依赖的核心组件是什么？  

MySQL事件是按预设时间/周期自动执行的SQL程序(如数据清理、统计)
依赖事件调度器(event_scheduler)进程监控和触发执行

#### 2、启用MySQL事件调度器的临时和永久方式分别是什么？  

临时启用:SET GLOBAL event_scheduler=ON
永久启用:修改配置文件(如my.cnf)添加event_scheduler = ON,重启MySQL生效

#### 3、MySQL事件支持哪两种触发模式？分别用什么语法定义？  

一次性触发:ON SCHEDULE AT '具体时间'（如AT 2025-12-31 23:59)  
周期性触发:ON SCHEDULE EVERY 时间间隔 [STARTS 开始时间](如EVERY 1 DAY STARTS 2025-01-01 03:00)

#### 4、创建定时任务时，`ON COMPLETION PRESERVE`的作用是什么？默认行为是什么？  

ON COMPLETION PRESERVE表示事件执行完成后保留(不自动删除)
默认行为是ON COMPLETION NOT PRESERVE(一次性事件执行后自动删除)

#### 5、定时任务适合处理哪些业务场景？不适合哪些场景？  

适合:数据库内部周期性操作(如每日清理过期数据、每小时统计订单)
不适合：实时性要求极高的任务(调度器有秒级延迟)、跨数据库/系统的复杂操作

#### 6、如何暂停一个正在运行的定时任务？如何彻底删除？  

暂停(禁用):ALTER EVENT 事件名 DISABLE
彻底删除:DROP EVENT IF EXISTS 事件名



### 数据库三范式

#### 1、数据库三范式

1NF:列不可分割(原子性)
2NF:消除非主属性对复合主键的部分依赖(基于1NF)
3NF:消除非主属性之间的传递依赖(基于2NF)

- 第一范式:原子性,确保表中的每个列是原子列,不可再分

- 第二范式:在满足第一范式的基础上,保证表中的所有非主键属性必须完全依赖与整个主键,而不能仅依赖于主键的一部分，解决的是复合主键下,表中数据冗余和更新异常的问题
- 第三范式:在满足第二范式的基础上,所有的非主键属性之间不能存在依赖关系,非主键属性必须直接依赖主键属性，解决的是非主键属性对主键的依赖传递问题(非主键属性之间存在依赖)

#### 2、什么是数据库范式？其核心目的是什么？  

数据库范式(Normal Form)是关系型数据库设计的规范,用于指导表结构设计以减少数据冗余和避免更新异常
核心目的是通过合理拆分表,确保数据的一致性和存储效率 

#### 3、第一范式（1NF）的定义是什么？请举例说明“不满足1NF”和“满足1NF”的情况。  

第一范式要求表中所有字段都是不可分割的原子值(即字段不能再拆分为更小的子字段)
不满足1NF的例子:user_info表中“联系方式”字段存储“电话:13800138000,邮箱:test@qq.com”(可拆分为电话和邮箱两个子字段)
满足1NF的例子:将“联系方式”拆分为phone和email两个独立字段,每个字段都是不可分割的原子值  

#### 4、第二范式（2NF）的前提是什么？其核心要求是什么？  

第二范式的前提是表必须满足1NF,且核心要求是非主属性完全依赖于主键(即不能存在部分依赖:非主属性只依赖于主键的一部分)
例如:订单明细表中,主键为(订单ID,商品ID),若商品名称只依赖于商品ID(主键的一部分),则不满足2NF
需将商品名称移至商品表,通过商品ID关联,实现完全依赖  

#### 5、第三范式（3NF）的前提是什么？其核心要求是什么？与2NF的区别是什么？  

第二范式的前提是表必须满足1NF,且核心要求是非主属性完全依赖于主键(即不能存在部分依赖:非主属性只依赖于主键的一部分)
例如:订单明细表中,主键为(订单ID,商品ID),若商品名称只依赖于商品ID(主键的一部分),则不满足2NF
需将商品名称移至商品表,通过商品ID关联,实现完全依赖  

#### 6、满足三范式的表一定是“好的设计”吗？为什么需要“反范式化”？  

不一定
三范式虽减少冗余,但可能导致表数量过多,查询时需频繁关联(如多表JOIN),降低查询性能  
反范式化是指有选择地增加冗余字段,减少表关联,提升查询效率适合读多写少的场景
如:电商商品详情页,将商品分类名称冗余到商品表,避免关联分类表

#### 7、请用一个实例说明“不满足第三范式”可能导致的“更新异常”。  

例如现在有一张学生表:维护学生的学号,学生的老师编号以及老师的手机号
现在这张表的字段存在依赖传递问题,老师的手机号依赖老师的编号,老师的编号依赖学生学号,不满足第三范式
假如有一条数据:1号学生对应的老师编号是101,老师的手机号是123
那么现在如果我们更新1号学生的教师手机号为456,那么该学生表中其它学号的学生对应的101号教师的手机号就不匹配了,出现更新异常
解决这个问题的方式有两种:

1. 更新1号学生信息的同时,要更新表中所有该教师的手机号,非常麻烦
2. 设计更规范的表,将学生表拆分成两张表,将教师的手机号和教师编号单独使用教师表维护学生表只维护学号和直接依赖的教师编号即可,这就是符合数据库设计的第三范式,消除非主键对主键的传递依赖



### 事务

#### 1、什么是事务？请用生活中的例子类比事务的核心特性。  

事务指的是满足ACID特性的一组操作,可以通过commit提交一个事务,也可以使用rollback进行回滚。
生活例子:转账(从A账户扣款,向B账户入账)必须两个操作同时成功(A扣款且B到账)或同时失败(A不扣款且B不到账)
对应事务的原子性,转账前后A和B的总金额不变,对应一致性  

#### 2、事务的ACID特性中，“原子性”和“持久性”分别依赖MySQL的哪些机制实现？ 

原子性:依赖undo log(回滚日志)记录操作的反向逻辑,事务失败时通过undo log撤销已执行的修改  
持久性:依赖redo log(重做日志)事务提交时先将修改写入redo log(磁盘)即使数据库崩溃,重启后可通过redo log恢复已提交的修改  

#### 3、事务的隔离级别中，“读已提交（RC）”和“可重复读（RR）”的核心区别是什么？MySQL的InnoDB默认使用哪种？  

核心区别: 

- RC级别下,事务中两次读取同一数据可能因其他事务提交而不一致(不可重复读)
- RR级别下,事务中多次读取数据结果一致(通过MVCC和间隙锁实现)
  InnoDB默认隔离级别是可重复读(RR)

#### 4、什么是“脏读”？如何通过隔离级别避免脏读？  

脏读是指事务A读取到事务B未提交的修改(若B回滚,A读到的数据无效) 
避免方式:将隔离级别设置为读已提交(RC)及以上(RC级别保证事务只能读取其他事务已提交的修改  

#### 5、长事务有哪些风险？如何优化长事务？  

风险包括:占用锁资源导致并发阻塞、产生大量undo log占用磁盘空间、数据库崩溃后恢复时间长
优化方案:拆分长事务为短事务(如批量更新分批次执行),减少事务中的非数据库操作(如网络请求),合理设置锁等待超时时间  

#### 6、事务的“一致性”与数据库三范式的“一致性”有何区别？  

事务的一致性:指事务执行前后,数据从一个合法状态转换到另一个合法状态(如库存不能为负)是运行时的数据正确性保障  
三范式的一致性:指表结构设计中数据无冗余、无异常,是设计时的数据存储合理性保障

#### 7、MySQL中如何手动控制事务？请写出“转账”场景的事务控制代码示例。  

```mysql
-- 转账示例(A账户向B账户转100元):
BEGIN; -- 开启事务
UPDATE accounts SET balance = balance - 100 WHERE id = 'A'; -- A扣款
UPDATE accounts SET balance = balance + 100 WHERE id = 'B'; -- B入账
COMMIT; -- 提交事务（若两句都成功）
-- 若中间出错，执行 ROLLBACK; 撤销所有修改
```



#### 8、事务的四大特性

- 原子性:是指事务是一个不可分隔的整体,事务的所有操作,要么全部提交成功,要么全部失败回滚
  回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可
- 一致性:是指事务中,事务前后的数据必须保持一致,例如转账业务中,转帐前和转账后,总金额必须一致
- 隔离性:多个并发事务之间互不干扰,每个事务感觉不到其他事务同时执行
- 持久性:一旦事务提交,则其所做的修改将会永远保存到数据库中,即使系统发生崩溃也不会丢失

#### 9、事务的四大并发一致性问题

- 脏读:事务A读取了事务B未提交的修改,若事务B最终回滚,事务A读到的就是无效数据(脏数据)
- 不可重复读:事务A内多次读取同一数据,期间事务B修改并提交了该数据,导致事务A前后读取结果不一致
- 幻读:事务A按条件查询一批数据,期间事务B新增或删除了符合该条件的记录,导致事务A两次查询结果集不一致
- 丢失更新:两个事务同时读取同一数据并修改,后提交的事务会覆盖前一个事务的修改,导致前者更新丢失

#### 10、事务的隔离级别

- Read uncommitted 读未提交:可能出现任何事务的并发问题
- Read committed 读已提交:解决了脏读问题(oracle默认)
- Repeatable read 可重复读:解决了脏读和不可重复读问题(mysql默认)
- Serializable 序列(串行)化:都不会出现

#### 11.三级封锁协议

1级:事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁
可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

2级:在1级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁
可以解决读脏数据问题,因为如果一个事务在对数据A进行修改,根据1级封锁协议,会加X锁,那么就不能再加S锁了,也就是不会读入数据

3级:在2级的基础上,要求读取数据A时必须加S锁,直到事务结束了才能释放S锁
可以解决不可重复读的问题因为读A时,其它事务不能对A加X锁,从而避免了在读的期间数据发生改变

#### 12.使用存储过程，完成转账业务操作

```mysql
-- 需求
-- （1）查询余额 > 1000 的 就可以转账， 小于 1000， 提示余额不足
-- （2）转账过程中出现异常，就回滚事务  
DROP PROCEDURE IF EXISTS transfer_money;
CREATE PROCEDURE transfer_money(
IN out_id INT,  -- 转出账户
IN in_id INT,   -- 转入账户
IN `money` DECIMAL(10, 2),   -- 转账金额
OUT result_msg  VARCHAR(255)   -- 转账结果
)
label: BEGIN
DECLARE out_balance DECIMAL(10, 2);   -- 转出账户的余额
DECLARE has_in_id INT DEFAULT 0;   -- 判断转入账户是否存在
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
  ROLLBACK; 
  SET result_msg := '转账失败，系统出现异常，请重试！';
END;
SELECT count(*) INTO has_in_id FROM `account` WHERE id = in_id; 
IF has_in_id = 0 THEN SET result_msg = '转入账户不存在！';
  LEAVE label;
END IF; 
START transaction;   
-- 查询转出账户余额
SELECT balance INTO out_balance FROM `account` WHERE id = out_id;
-- 判断余额
IF out_balance >= `money` THEN
    -- 转出账户减钱
   UPDATE account SET balance = balance - `money`  WHERE  id = out_id;
   -- 模拟的sql异常  
   -- select * from ccc;
   -- 转入账户加钱
   UPDATE account SET balance = balance + `money`  WHERE id =  in_id;
   COMMIT;
   SET result_msg = '转账成功';
ELSE 
  ROLLBACK;
  SET result_msg = '转账失败，您的余额不足！';
END IF;
select result_msg;
END;
```








### 存储引擎

#### 1、什么是存储引擎？MySQL中常见的存储引擎有哪些？  

存储引擎:是数据库管理系统中负责数据存储、检索和管理的核心组件,决定了数据的存储方式、支持的功能(如事务、锁)等  
常见存储引擎:InnoDB(默认)、MyISAM、Memory、Archive等  

#### 2、InnoDB和MyISAM的核心区别是什么？（高频考点）  

| 维度     | InnoDB                           | MyISAM                           |
| -------- | -------------------------------- | -------------------------------- |
| 事务支持 | 支持ACID事务、事务回滚           | 不支持事务                       |
| 锁机制   | 支持行级锁（粒度细，并发高）     | 仅支持表级锁（粒度粗，并发低）   |
| 索引类型 | 聚簇索引（主键索引存数据）       | 非聚簇索引（索引和数据分离）     |
| 外键支持 | 支持外键                         | 不支持外键                       |
| 崩溃恢复 | 支持（依赖redo/undo日志）        | 不支持（崩溃后可能数据损坏）     |
| 适用场景 | 读写频繁、需要事务（如订单系统） | 读多写少、无需事务（如博客系统） |

#### 3、为什么InnoDB是MySQL的默认存储引擎？  

1. 支持事务和ACID特性,保证数据一致性
2. 行级锁支持高并发场景,减少锁冲突
3. 聚集索引设计提升查询效率
4. 支持崩溃恢复和外键,适合复杂业务场景(如电商、金融)

#### 4、Memory存储引擎的特点和适用场景？  

特点:数据存于内存,读写速度极快,不支持事务,服务重启后数据丢失  
适用场景:临时数据缓存(如会话数据),高频访问的小表(如字典表)

#### 5、说说mysql 体系结构

- 连接层:主要负责连接处理、授权认证、安全方案等功能
- 服务层:主要负责数核心服务功能,比如sql接口,完成缓存查询,内置函数的执行等功能
- 引擎层:存储引擎主要负责mysql中数据的存储和提取。
- 存储层:主要负责将数据存储到磁盘文件中

#### 6、存储引擎的选择

在选择存储引擎时,应该根据应用系统的特点选择合适的存储引擎
对于复杂的应用系统,还可以根据实际情况选择多种存储引擎进行组合
InnoDB:是Mysql的默认存储引擎,支持事务、外键。
对事务的完整性有比较高的要求,在并发条件下要求数据的一致性,数据操作除了插入和查询之外,还包含很多的更新、删除操作
MyISAM:以读操作和插入操作为主,很少的更新和删除操作,并且对事务的完整性、并发性要求不是很高
MEMORY:将所有数据保存在内存中,访问速度快,通常用于临时表及缓存。
MEMORY的缺陷就是对表的大小有限制,太大的表无法缓存在内存中,而且无法保障数据的安全性



### 索引

#### 1、什么是索引？索引的核心作用是什么？  

索引:是表中一列或多列的值排序后的结构,类似书籍目录


#### 2、常见的索引类型有哪些？  

按结构分: B+树索引（最常用）、哈希索引、全文索引、R树索引
按功能分:

  - 聚集索引(主键索引,叶子节点存完整数据)  
  - 非聚集索引(二级索引,叶子节点存主键值)  
  - 联合索引(多列组合索引)  
  - 唯一索引(值唯一，如身份证号)  

结构:

- 主键索引:针对于表中主键创建的索引,默认自动创建,只能有一个,关键字:PRIMARY

- 唯一索引:避免同一个表中某数据列中的值重复,可以有多个,关键字:UNIQUE

- 普通索引:快速定位特定数据

- 全文索引:全文索引查找的是文本中的关键词,而不是比较索引中的值

功能:

- 聚集索引/聚集索引(Clustered Index):将数据存储与索引放到了一块,索引结构的叶子节点保存了行数据

- 二级索引/非聚集索引(Secondary Index):将数据与索引分开存储,索引结构的叶子节点关联的是对应的主键

#### 3、B+树索引的优势是什么？（高频考点）  

叶子节点按顺序链表连接,支持范围查询(如:BETWEEN、ORDER BY)
非叶子节点仅存索引键,索引树高度低(通常3-4层)查询效率高 
所有数据存在叶子节点,查询结果稳定(每次查询路径长度一致) 

#### 4、聚集索引和非聚集索引的区别？  

- 聚集索引:索引和数据存于同一文件,叶子节点即数据行,查询时找到索引即可获取数据,效率高
- 非聚集索引:索引和数据分离,叶子节点存数据地址,查询时需先查索引,再通过地址取数据(回表),效率较低
- 聚集索引的特点是:默认使用主键创建聚集索引,叶子节点保存了整行数据
- 非聚集索引的特点是:使用其它字段创建的例如单列索引、联合索引都是非聚集索引
  叶子节点保存的是主键,如果不能在非聚集索引表中直接查询到数据,那么需要回聚集索引表查询数据,也就是回表查询

#### 5、哪些情况会导致索引失效？（高频考点）  

1. 索引列使用函数(如:SUBSTR(name,1,2)='张')
2. 模糊查询前导为%(如:name LIKE '%三')  
3. OR连接的列中有非索引列(如:id=1 OR age=20,若age无索引)  
4. 隐式类型转换(如:phone='123',若phone是int类型)  
5. 违反联合索引“最左前缀原则”(如:联合索引(a,b,c),查询b=1会失效)
6. 数据量极少的表  

#### 6、联合索引的“最左前缀原则”是什么？  

1. 联合索引(a,b,c)的生效顺序为a → a,b → a,b,c
2. 若查询条件不包含最左列(如b=1或b=1 AND c=2),索引失效  
3. 设计时需将高频查询列放左侧,如:(用户ID, 订单时间)  

#### 7、为什么不建议大量创建索引？  

写入(INSERT/UPDATE/DELETE)时需维护索引结构,耗时增加
优化器可能选择低效索引,反而降低查询性能

#### 8、InnoDB为什么推荐使用自增主键作为聚集索引？  

自增主键保证新数据追加到索引树末尾,避免索引树分裂(减少碎片)
自增主键值小且连续,节省索引空间  
若用非自增主键(如UUID)会导致索引树频繁分裂,降低性能  

#### 9、为什么InnoDB存储引擎选择使用B+tree索引结构?

相对于二叉树,b+tree层级更少,搜索效率高
B-tree无论是叶子节点还是非叶子节点,都会保存数据
这样导致一页中存储的键值减少,指针跟着减少,同样保存大量数据,只能增加树的高度,导致性能降低
相对Hash索引,B+tree支持范围匹配及排序操作

#### 10、聚集索引选取的规则？

如果存在主键,主键索引就是聚集(聚簇)索引
如果不存在主键,将使用第一个唯一(UNIQUE)索引作为聚集(聚簇)索引
如果表没有主键,或没有合适的唯一索引,则InnoDB会自动生成一个rowid作为隐藏的聚集索引

#### 11、聚集索引和二级索引谁的查询的效率高？为什么？

聚集索引的效率高
聚集索引将数据存储与索引放到了一块,二级索引将数据与索引分开存储
它的索引结构的叶子节点关联的是对应的主键,使用二级索引查询,还是需要回表查询聚集索引






### 数据库锁 

#### 1、数据库锁的核心作用是什么？  

协调并发事务对共享资源的访问,保证数据一致性(避免脏读、不可重复读、幻读)同时平衡并发性能

#### 2、MySQL 中有哪些锁类型？（按粒度/类型分类）

按粒度:表锁(MyISAM),行锁(InnoDB),页锁(少见)
按类型:共享锁(S锁,只读),排他锁(X锁,读写)  
特殊锁:意向锁(IS/IX,表级),间隙锁(Gap Lock,范围锁),临键锁(Next-Key Lock,记录+间隙锁)  

#### 3、行锁和表锁的区别是什么？  

| 维度     | 行锁（InnoDB）       | 表锁（MyISAM）     |
| -------- | -------------------- | ------------------ |
| 锁定粒度 | 单行记录             | 整张表             |
| 并发能力 | 高（支持多事务并行） | 低（锁冲突概率高） |
| 开销     | 大（加锁慢）         | 小（加锁快）       |
| 死锁     | 可能发生             | 不会发生           |

#### 4、InnoDB 的行锁是如何实现的？为什么行锁必须基于索引？  

InnoDB 行锁通过索引实现(LOCK IN SHARE MODE)(FOR UPDATE)
若SQL条件命中索引(如:WHERE id=1)则锁定对应索引行  
若条件无索引(如:WHERE name='xxx')则行锁退化为表锁(全表扫描并锁定所有行)

#### 5、间隙锁（Gap Lock）和临键锁（Next-Key Lock）的作用是什么？  

- 间隙锁:锁定索引区间的间隙(如:WHERE id BETWEEN 1 AND 10会锁定(1,10)的间隙)防止其他事务插入新数据,解决幻读  
- 临键锁:间隙锁+记录锁(如锁定id=5及之前的间隙),是InnoDB可重复读(RR)隔离级别的默认锁算法

#### 6、什么是 MVCC？它如何与锁机制协同工作？  

MVCC(多版本并发控制)通过保存数据的多个版本(Undo Log+隐藏字段 trx_id/roll_pointer)实现读并发
快照读(普通 SELECT):基于事务启动时的Read View读取历史版本,无需加锁  
当前读(SELECT FOR UPDATE/UPDATE):加行锁或间隙锁,确保读取最新数据并阻止并发修改 

#### 7、MySQL 死锁的常见原因是什么？如何排查和解决？  

- 原因:循环锁等待(如事务A锁表1→等表2,事务B锁表2→等表1),锁粒度冲突(行锁与表锁),索引失效导致锁范围过大
- 排查:SHOW ENGINE INNODB STATUS\G查看死锁日志,或查询performance_schema.innodb_lock_waits 
- 解决:固定锁顺序(如按表名升序加锁),缩短事务时长,设置锁超时(innodb_lock_wait_timeout) 

#### 8、如何优化数据库锁的性能？    

1. 索引优化:确保SQL走索引,避免行锁变表锁:
2. 事务优化:缩小事务范围(只包含必要操作),避免长事务  
3. 锁粒度优化:用行锁替代表锁,或用乐观锁(版本号)减少锁竞争  
4. 隔离级别优化:读已提交(RC)比可重复读(RR)锁竞争更少(需业务容忍不可重复读)

#### 9、事务隔离级别如何影响锁的行为？  

1. 读未提交(RU):无锁,直接读未提交数据(脏读风险)
2. 读已提交(RC):快照读(MVCC),当前读加行锁(防止脏读,仍有不可重复读/幻读)  
3. 可重复读(RR):快照读复用Read View,当前读加间隙锁/临键锁(防止不可重复读,幻读需依赖间隙锁)
4. 串行化(SERIALIZABLE):所有操作加表锁,事务串行执行(无并发,但最安全)

#### 10、为什么 InnoDB 的可重复读（RR）能防止幻读？  

RR级别通过MVCC(快照读)+间隙锁/临键锁(当前读)协同实现
快照读:事务内多次查询基于同一Read View,只能看到事务启动前已提交的数据  
当前读:加间隙锁锁定范围,阻止其他事务插入新数据,从而避免幻读

#### 11、执行 `SELECT * FROM table WHERE id=1 FOR UPDATE` 时，InnoDB 加了什么锁？  

若id是唯一索引,加行锁(Record Lock),若id无索引,加表锁

#### 12、如何避免“修改丢失”问题？  

1. 用排他锁(如:SELECT ... FOR UPDATE)或乐观锁(版本号)
2. 悲观锁:BEGIN,SELECT ... FOR UPDATE,UPDATE ...,COMMIT  
3. 乐观锁:UPDATE table SET num=num+1,version=version+1 WHERE id=1 AND version=old_version 

#### 13、判断对错并说明理由：

InnoDB 的行锁一定比表锁性能好.错:行锁加锁开销大,小表全表更新时表锁更高效(如MyISAM表锁)
只要使用了索引,InnoDB 就会加行锁，不会升级为表锁,错:索引失效(如函数操作索引列)时,行锁会退化为表锁
MySQL的可重复读(RR)隔离级别完全避免了幻读,对:InnoDB的RR通过间隙锁/临键锁避免幻读，超出了sql标准定义的 RR 能力`

#### 14、共享锁（S 锁）和排他锁（X 锁）的兼容规则是什么？举例说明哪些 SQL 操作会自动加这两种锁。

兼容规则：S锁 和 S 锁兼容，S 锁与 X 锁互斥，X 锁与所有锁互斥
示例：
S 锁： select ... lock in share mode (共享读锁)
X 锁： update/delete（独占写锁，自动加 X 锁）

#### 15、间隙锁（Gap Lock）和临键锁（Next-Key Lock）的触发条件是什么？为什么 InnoDB 需要这两种锁？

- 触发条件：InnoDB 在 RR 隔离级别下，对索引列的范围查询（如 >、between）触发
- 作用：通过锁定索引间隙，组织新数据插入，解决幻读问题（临键锁是`记录锁` 和 `间隙锁` 的组合）



### 经典代码案例

以下是MySQL数据库常用的代码案例,涵盖表设计、CRUD 操作、事务、索引、存储过程等核心场景,贴近实际开发需求：


#### 1、表结构设计案例  

##### 1.1 基础表设计（用户表+订单表，含主键、外键、约束）  

```mysql
-- 用户表（基础信息）
CREATE TABLE `user` (
`id` INT AUTO_INCREMENT COMMENT '用户ID（主键）',
`username` VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名（唯一）',
`phone` VARCHAR(20) NOT NULL COMMENT '手机号',
`age` TINYINT CHECK (age >= 0 AND age <= 120) COMMENT '年龄（0-120校验）',
`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
PRIMARY KEY (`id`),
INDEX idx_phone (`phone`)  -- 手机号索引（加速查询）
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '用户信息表';

-- 订单表（关联用户表，含外键）
CREATE TABLE `order` (
`id` BIGINT AUTO_INCREMENT COMMENT '订单ID',
`order_no` VARCHAR(32) NOT NULL UNIQUE COMMENT '订单编号',
`user_id` INT NOT NULL COMMENT '关联用户ID',
`amount` DECIMAL(10,2) NOT NULL COMMENT '订单金额',
`status` TINYINT NOT NULL DEFAULT 0 COMMENT '状态（0-待支付，1-已支付）',
PRIMARY KEY (`id`),
INDEX idx_user_id (`user_id`),  -- 关联查询索引
-- 外键约束（订单必须属于存在的用户）
FOREIGN KEY (`user_id`) references `user`(`id`) ON DELETE cascade
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT '订单表';
```

#### 2、CRUD 核心操作案例  

##### 2.1 插入数据（单条+批量）  

```mysql
-- 单条插入
INSERT INTO `user` (username, phone, age) 
VALUES ('zhangsan', '13100001111', 25);

-- 批量插入（高效，减少IO）
INSERT INTO `order` (order_no, user_id, amount, status) 
VALUES 
('20231001001', 1, 99.99, 0),
('20231001002', 1, 199.50, 1),
('20231001003', 2, 299.00, 0);
```

##### 2.2 查询数据（基础+关联+聚合）  

```mysql
-- 基础查询（带条件+排序）
SELECT id, username, age 
FROM `user` 
WHERE age BETWEEN 18 AND 30 
ORDER BY create_time DESC 
LIMIT 10;

-- 关联查询（用户+订单，统计用户总消费）
SELECT 
u.id, u.username, 
COUNT(o.id) AS order_count,  -- 订单总数
SUM(o.amount) AS total_amount  -- 总消费
FROM `user` u
LEFT JOIN `order` o ON u.id = o.user_id
GROUP BY u.id, u.username
HAVING total_amount > 0;  -- 筛选有消费的用户
```

##### 2.3 更新与删除（带条件+限制）  

```mysql
-- 更新（安全更新，带WHERE条件）
UPDATE `order` 
SET status = 1, amount = amount  1.05  -- 支付成功，金额加5%
WHERE order_no = '20231001001';

-- 删除（逻辑删除，而非物理删除，保留数据）
ALTER TABLE `user` ADD COLUMN is_delete TINYINT DEFAULT 0 COMMENT '是否删除（0-否，1-是）';
UPDATE `user` SET is_delete = 1 WHERE id = 3;  -- 标记删除
```

#### 3、事务与锁案例  

##### 3.1 事务控制（转账场景，确保原子性）  

```mysql
-- 转账：用户1向用户2转100元（需关联账户表）
CREATE TABLE `account` (id INT, user_id INT, balance DECIMAL(10,2), PRIMARY KEY(id));
BEGIN;  -- 开启事务
-- 步骤1：检查转出账户余额
SELECT balance FROM `account` WHERE user_id = 1 FOR UPDATE;  -- 加排他锁，防止并发修改
-- 步骤2：扣减转出账户
UPDATE `account` SET balance = balance - 100 WHERE user_id = 1;
-- 步骤3：增加转入账户
UPDATE `account` SET balance = balance + 100 WHERE user_id = 2;
-- 无异常则提交
COMMIT;
-- 若出错，回滚（如余额不足）
-- ROLLBACK;
```

#### 4、索引与性能优化案例  

##### 4.1 索引设计（联合索引+最左前缀原则）  

```mysql
-- 为订单表创建联合索引（优化多条件查询）
CREATE INDEX idx_user_status ON `order`(user_id, status);

-- 有效利用索引的查询（符合最左前缀）
EXPLAIN SELECT FROM `order` 
WHERE user_id = 1 AND status = 0;  -- 命中联合索引

-- 索引失效的查询（跳过左列）
EXPLAIN SELECT FROM `order` 
WHERE status = 0;  -- 未使用联合索引（未匹配user_id）
```

#### 5、存储过程与触发器案例  

##### 5.1 存储过程（批量生成测试数据）  

```mysql
-- 批量插入N条随机用户数据
DELIMITER //
CREATE PROCEDURE batch_insert_user(IN n INT)
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0;  -- 关闭自动提交，提升效率
WHILE i < n DO
 INSERT INTO `user` (username, phone, age)
 VALUES (
   CONCAT('user_', FLOOR(RAND()100000)),  -- 随机用户名
   CONCAT('131', FLOOR(RAND()10000000)),  -- 随机手机号
   FLOOR(RAND()80 + 18)  -- 18-98岁随机年龄
 );
 SET i = i + 1;
END WHILE;
COMMIT;  -- 批量提交
SET autocommit = 1;
END //
DELIMITER ;

-- 调用：插入1000条测试数据
CALL batch_insert_user(1000);
```

##### 5.2 触发器（数据校验+自动维护）  

```mysql
-- 插入订单时，自动校验金额必须>0
DELIMITER //
CREATE TRIGGER check_order_amount 
BEFORE INSERT ON `order`
FOR EACH ROW
BEGIN
IF NEW.amount <= 0 THEN
 SIGNAL SQLSTATE '45000' 
 SET MESSAGE_TEXT = '订单金额必须大于0';
END IF;
END //
DELIMITER ;
```

#### 6、分页与高级查询案例  

##### 6.1 分页查询（避免一次性加载大量数据）  

```sql
-- 分页查询第3页数据（每页20条）
SELECT id, username, phone 
FROM `user` 
WHERE is_delete = 0 
ORDER BY create_time DESC 
LIMIT 40, 20;  -- 偏移量=（页码-1）每页条数
```

##### 6.2 窗口函数（排名统计，MySQL 8.0+）  

```sql
-- 按用户消费金额排名（降序）
SELECT 
u.username,
SUM(o.amount) AS total_amount,
RANK() OVER (ORDER BY SUM(o.amount) DESC) AS rnk  -- 排名（相同金额并列）
FROM `user` u
JOIN `order` o ON u.id = o.user_id
GROUP BY u.id, u.username;
```

