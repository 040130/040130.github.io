---
title: 项目
date: 2019-09-21
background: /assets/t_3.jpg
---

### 你做过什么项目？（高）


我最近完成了一个《服装电商类项目》，在这个项目中，我主要负责前端开发。前端`UI`界面是用鸿蒙应用`App`开发的，而后端管理界面则是使用`Vue3`和`Element-Plus`构建的。虽然后端`API`是由其他同事开发的，技术栈是`SSM`，但我在项目中与前端的对接和调试方面积累了丰富的经验。这个项目让我深入理解了前端与后端的协作流程，也提升了我在鸿蒙应用开发和`Vue3`框架下的实际开发能力。



### 项目什么时候做的？有多少人负责？（高）


这个项目是我在实习期间完成的，具体时间是`2024年3月到2024年8月`（根据你的实际情况调整）。整个团队大约有`5`人，其中前端开发有`2`人（包括我），后端开发有2人，还有1位负责测试和1位产品设计的同事。我在团队中主要负责前端开发，包括鸿蒙应用`App`的`UI`实现和部分后端管理界面的开发。



### 项目用了什么技术栈？（高）

这个项目的前端部分主要分为两块：

**用户端：** 

是用鸿蒙应用`App`开发的，主要使用了鸿蒙的`ArkUI`框架和`JavaScript`/`TypeScript`语言来实现`UI`界面和交互逻辑。

**管理端：** 

是用`Vue3`和`Element-Plus`开发的，主要用来处理后台管理系统的界面和功能，比如商品管理、订单管理等。后端技术栈是`SSM`（`Spring`、`Spring MVC`、`MyBatis`），数据库用的是`MySQL`，虽然后端开发不是我负责的，但我在项目中和后端同事有密切的对接，比如接口联调和数据格式的协商。



### 项目有什么功能？你负责了哪些功能？（高）

这是一个服装电商类项目，主要分为用户端和管理端两部分：

**用户端：** 用户可以通过鸿蒙应用`App`浏览商品、加入购物车、下单支付、查看订单状态等。

**管理端：** 管理员可以通过后台管理系统管理商品（增删改查）、处理订单、查看销售数据等。

在项目中，我主要负责以下功能模块的开发：

1. **用户端：**
   - **商品列表页：** 使用鸿蒙的`ArkUI`框架实现了商品列表的展示，支持分页加载和图片懒加载，优化了页面性能。
   - **商品详情页：** 实现了商品详情展示、规格选择、加入购物车等功能，使用了鸿蒙的自定义组件和动画库来提升用户体验。
   - **购物车模块：** 实现了购物车的增删改查功能，并与后端接口对接，确保数据实时同步。
2. **管理端：**
   - **商品管理模块：** 使用`Vue3`和`Element-Plus`开发了商品管理的增删改查功能，包括商品信息的表单校验和图片上传功能。
   - **订单管理模块：** 实现了订单列表的展示和状态更新功能，支持按条件筛选和分页查询。

在开发过程中，我遇到了一些挑战，比如：

- **性能优化：** 在商品列表页中，图片懒加载和分页加载的实现需要兼顾性能和用户体验，我通过鸿蒙的`List`组件和自定义指令优化了渲染效率。
- **接口对接：** 在购物车模块中，需要与后端`API`频繁交互，我使用`Axios`封装了统一的请求工具，并处理了接口的错误状态和超时问题。

### 项目遇到了什么问题？你是如何解决的？（中）

在项目中，我遇到了一些技术挑战和协作问题，以下是两个典型的例子：

1. **用户端图片加载性能问题**
   在开发商品列表页时，由于商品图片数量较多，直接加载所有图片导致页面卡顿，用户体验较差。
   **解决方案：**
   - 我使用了鸿蒙的`List`组件和图片懒加载技术，只有当图片进入用户可视区域时才加载图片。
   - 同时，我对图片进行了压缩和`CDN`加速，进一步减少了加载时间。
   - 最终，页面加载速度提升了约40%，用户体验显著改善。
2. **管理端表单校验复杂性问题**
   在商品管理模块中，商品信息的表单字段较多，校验规则复杂（如价格必须为数字、库存不能为负数等），直接手写校验逻辑会导致代码冗长且难以维护。
   **解决方案：**
   - 我使用了`Element-Plus`的表单组件，并通过校验规则配置实现了表单校验。- 我使用了Vue3的`vuelidate`库来实现表单校验，将校验规则抽象成独立的模块，便于复用和维护。
   - 同时，我为每个字段设计了清晰的错误提示信息，提升了用户操作的友好性。
   - 最终，表单校验代码量减少了约`30%`，且后续新增字段时只需简单修改校验规则即可。

此外，在团队协作中，我还遇到过前后端接口对接不一致的问题。为了解决这个问题，我主动与后端同事沟通，制定了统一的接口文档，并使用`Postman`进行接口测试，确保前后端数据格式一致。



### 这个项目最难的或者说你印象最深的是那个功能？（中）

在项目中，我印象最深的是用户端的购物车功能。这个功能看似简单，但实际上涉及复杂的交互逻辑和与后端的数据同步，开发过程中遇到了不少挑战。

1. **需求分析**
   购物车功能需要支持以下核心操作：
   - 添加商品到购物车。
   - 修改商品数量。
   - 删除商品。
   - 实时计算总价。
   - 与后端同步数据，确保用户在不同设备上登录时购物车数据一致。
2. **技术实现**
   - 我使用鸿蒙的ArkUI框架开发了购物车的`UI`界面，包括商品列表、数量选择器和总价计算区域。
   - 为了提升用户体验，我加入了动画效果，比如删除商品时的渐隐动画。
   - 购物车数据通过`API`与后端实时同步，我使用`Axios`封装了统一的请求工具，并处理了网络异常和超时问题。
3. **遇到的挑战**
   - 数据同步问题：由于购物车数据需要实时同步，而网络请求可能存在延迟或失败，我设计了一个本地缓存机制，在网络请求失败时先更新本地数据，待网络恢复后再同步到后端。
   - 性能问题：当购物车中商品数量较多时，频繁的`DOM`操作会导致页面卡顿。我通过虚拟列表技术优化了渲染性能，只渲染用户可见区域的商品项。
   - 交互复杂性：修改商品数量时需要实时计算总价，同时触发后端数据更新。我使用了鸿蒙的状态管理工具来确保数据的一致性，并通过防抖技术减少了不必要的`API`请求。
4. **最终成果**
   经过多次优化和测试，购物车功能最终实现了流畅的用户体验和稳定的数据同步。用户反馈非常好，尤其是在网络不稳定的情况下，本地缓存机制显著提升了使用体验。



### 平时遇到问题怎么解决？（高）

平时遇到问题时，我会按照以下步骤来解决：

1. **分析问题**
   首先，我会明确问题的本质和影响范围。比如，是代码报错、性能问题，还是需求理解不清？我会通过日志、调试工具或与同事沟通来定位问题的根源。
2. **独立尝试解决**
   在明确问题后，我会先尝试独立解决。比如：
   - 如果是代码问题，我会查阅官方文档、技术博客或社区论坛（如`Stack Overflow`、`GitHub Issues`）寻找解决方案。
   - 如果是性能问题，我会使用性能分析工具（如`Chrome DevTools`、鸿蒙的性能分析工具）来定位瓶颈。
   - 如果是技术选型问题，我会对比不同方案的优缺点，选择最适合当前场景的方案。
3. **寻求帮助**
   如果经过一段时间（比如半小时到一小时）仍然无法解决，我会主动寻求帮助。比如：
   - 向更有经验的同事请教，描述我已经尝试过的解决方案，以便他们快速理解问题。
   - 在技术社区发帖，附上详细的错误信息和代码片段，以便其他人更好地帮助我。
4. **总结和记录**
   问题解决后，我会总结问题的原因和解决方案，并记录下来。比如：
   - 如果是代码问题，我会在代码中添加注释，说明问题的背景和解决方案。
   - 如果是技术难点，我会整理成文档或博客，方便以后查阅，也帮助团队其他成员避免类似问题。
5. **举一个实际例子**
   比如，在开发购物车功能时，我遇到了商品数量更新后总价计算不准确的问题。我首先通过调试工具定位到问题出在数据同步的逻辑上，然后查阅了鸿蒙的状态管理文档，发现是因为状态更新没有及时触发。最终，我通过使用鸿蒙的`@State`和`@Watch`装饰器解决了这个问题，并将解决方案记录在团队的知识库中。



### 平时怎么学习？（高）

我平时的学习主要分为以下几个方面：

1. **系统化学习**

- **技术文档：** 我会定期阅读官方文档（如`Vue3`、鸿蒙、`React`等），了解最新的特性和最佳实践。比如，在学习鸿蒙开发时，我通过官方文档掌握了`ArkUI`框架的使用方法。
- **在线课程：** 我会选择一些高质量的在线课程（如慕课网、`Coursera`、`Udemy`等），系统地学习新技术。比如，我最近在学习前端性能优化相关的课程，掌握了如何通过懒加载和代码分割提升页面性能。

1. **实践驱动学习**
   - **项目实践：** 我认为实践是最好的学习方式。在工作中，我会将学到的新技术应用到实际项目中。比如，在学习`Vue3`的`Composition API`后，我将其用在了管理端的开发中，显著提升了代码的可维护性。
   - **个人项目：** 除了工作项目，我还会做一些个人项目来巩固学习成果。比如，我最近用`React`开发了一个个人博客，实践了服务端渲染（`SSR`）和静态站点生成（`SSG`）技术。
2. **社区和博客**
   - **技术社区：** 我经常参与技术社区（如`GitHub`、`Stack Overflow`、掘金等），阅读其他人的经验分享，并尝试解决社区中的问题。这不仅帮助我学到了很多实用的技巧，也让我了解了行业的最新动态。
   - **技术博客：** 我会定期阅读技术博客（如阮一峰的网络日志、前端早读课等），并尝试将学到的知识整理成自己的博客，分享给其他人。
3. **总结和复盘**
   - **学习笔记：** 我会将学习过程中的重点和难点记录下来，形成学习笔记。比如，在学习鸿蒙开发时，我整理了`ArkUI`框架的常用组件和`API`，方便以后查阅。
   - **项目复盘：** 每次完成一个项目后，我都会进行复盘，总结项目中的技术难点和解决方案，并思考如何改进。
4. **举一个实际例子**
   比如，在学习前端性能优化时，我通过阅读文档和课程掌握了懒加载和代码分割技术，并将其应用到了商品列表页的开发中，将页面加载时间减少了`30%`。



### 前端和后端如何交互？如何对接口？（高）

前端和后端主要通过`API`接口进行交互，具体流程如下：

1. **接口定义**

   - 在项目初期，前后端会一起讨论并确定接口的请求方式（如`GET`、`POST`）、`URL`路径、请求参数和返回数据格式。
   - 通常会使用接口文档工具（如`Swagger`、`YAPI`、`Apifox`）来规范接口定义，确保前后端对接口的理解一致。

2. **数据格式**

   - 前后端交互的数据格式通常是`JSON`，因为它轻量且易于解析。

   - 前端通过`axios`或`fetch`等工具发送请求，后端返回`JSON`格式的数据。

   - 例如，获取商品列表的接口可能是：

     ```json
     // GET /api/products 返回数据：
     {
       "code": 200,
       "data": [
         { "id": 1, "name": "T-shirt", "price": 99.9 },
         { "id": 2, "name": "Jeans", "price": 199.9 }
       ]
     }
     ```

3. **调试工具**

   - 在开发过程中，我会使用`Postman`或`Apifox`等工具测试接口，确保接口的正确性和稳定性。
   - 如果接口返回的数据格式或状态码不符合预期，我会与后端同事沟通，调整接口逻辑。

4. **错误处理**

   - 前端需要对接口的错误状态进行处理，比如网络错误、超时、`401`未授权、`404`未找到等。
   - 我通常会封装一个统一的请求工具（如基于`axios`的封装），在请求拦截器和响应拦截器中处理错误状态，并给出友好的用户提示。

5. **实际例子**
   比如，在开发购物车功能时，我需要与后端对接以下几个接口：

   - **添加商品到购物车：** `POST /api/cart`，请求体包含商品ID和数量。
   - **获取购物车列表：** `GET /api/cart`，返回当前用户的购物车商品列表。
   - **更新商品数量：** `PUT /api/cart/{id}`，请求体包含新的数量。
   - **删除商品：** `DELETE /api/cart/{id}`。

在对接过程中，我使用`Postman`测试了每个接口，并确保前端能够正确处理返回的数据和错误状态。比如，当用户未登录时，后端会返回`401`状态码，前端会跳转到登录页面。



### 平时是如何和后端对接的？（高）

在项目中，我与后端的对接主要分为以下几个步骤：

1. **需求分析和接口定义**
   - 在项目初期，我会与后端开发人员一起参与需求讨论，明确每个功能模块的业务逻辑和数据交互需求。
   - 我们会使用接口文档工具（如`Swagger`、`YAPI`、`Apifox`）来定义接口的请求方式、`URL`路径、请求参数和返回数据格式。比如，在开发购物车功能时，我们定义了以下接口：
     - 获取购物车列表：`GET /api/cart`
     - 添加商品到购物车：`POST /api/cart`
     - 更新商品数量：`PUT /api/cart/{id}`
     - 删除商品：`DELETE /api/cart/{id}`
2. **接口调试**
   - 在接口定义完成后，我会使用`Postman`或`Apifox`等工具测试接口，确保接口的正确性和稳定性。
   - 如果接口返回的数据格式或状态码不符合预期，我会及时与后端开发人员沟通，调整接口逻辑。
3. **数据格式和错误处理**
   - 前后端交互的数据格式通常是`JSON`。我会根据接口文档，确保前端发送的请求参数和接收的返回数据格式正确。
   - 对于接口的错误状态（如`401`未授权、`404`未找到、`500`服务器错误等），我会在前端进行统一处理。比如，当用户未登录时，后端返回`401`状态码，前端会跳转到登录页面。
4. **联调和问题解决**
   - 在开发过程中，我会与后端开发人员保持密切沟通，定期进行接口联调，确保前后端的数据交互没有问题。
   - 如果遇到问题，我会先通过日志和调试工具定位问题，然后与后端开发人员一起分析原因并解决。比如，在开发订单功能时，我发现订单状态更新接口返回的数据格式与文档不一致，经过沟通后，后端同事调整了接口逻辑。
5. **实际例子**
   比如，在开发商品列表页时，我需要与后端对接获取商品列表的接口。我们定义了接口的请求方式为`GET /api/products`，返回的数据包括商品`ID`、名称、价格和图片`URL`。在调试过程中，我发现图片`URL`的字段名与文档不一致，经过沟通后，后端同事修正了字段名，确保了前后端的数据一致性。



### 项目如何优化？（中）

在项目中，我从以下几个方面对项目进行了优化：

1. **前端性能优化**
   - **图片懒加载：** 在商品列表页中，我实现了图片懒加载功能，只有当图片进入用户可视区域时才加载图片，减少了初始页面加载时间。
   - **代码分割：** 使用`Vue3`的`import()`动态导入功能，将代码按路由拆分成多个`chunk`，减少了首屏加载的 `JavaScript` 体积。
   - **缓存策略：** 对静态资源（如`CSS`、`JS`、图片）设置了合适的缓存策略，减少了重复请求。
2. **用户体验优化**
   - **加载状态提示：** 在数据加载时，增加了加载动画和骨架屏，提升了用户体验。
   - **错误处理：** 对接口请求的错误状态（如网络错误、超时、`401`未授权等）进行了统一处理，并给出友好的用户提示。
   - **交互优化：** 在购物车功能中，加入了动画效果（如删除商品时的渐隐动画），提升了交互体验。
3. **代码质量优化**
   - **模块化开发：** 将通用的功能（如表单校验、请求封装）抽象成独立的模块，提升了代码的可维护性和复用性。
   - **代码规范：** 使用`ESLint`和`Prettier`规范代码风格，确保团队代码风格一致。
   - **单元测试：** 为核心功能（如购物车逻辑、表单校验）编写了单元测试，确保代码的稳定性和可维护性。
4. **后端接口优化**
   - **接口合并：** 在商品列表页中，将多个接口合并成一个接口，减少了请求次数。
   - **分页和懒加载：** 对大数据量的接口（如商品列表）实现了分页和懒加载，减少了单次请求的数据量。
5. **实际例子**
   比如，在优化商品列表页时，我发现页面加载时间较长，经过分析发现是因为图片加载过多。我通过实现图片懒加载和`CDN`加速，将页面加载时间从X秒减少到`Y`秒，显著提升了用户体验。



### 从项目中获得了什么？（低）

从这个项目中，我获得了以下几方面的收获：

1. **技术能力的提升**
   - **鸿蒙应用开发：** 通过开发用户端界面，我深入掌握了鸿蒙的ArkUI框架和`JavaScript`/`TypeScript`语言，能够熟练实现复杂的UI交互和动画效果。
   - **Vue3开发：** 在管理端开发中，我熟练使用了`Vue3`的组合式`Composition API`和`Element-Plus`组件库，提升了代码的可维护性和开发效率。
   - **前后端对接：** 通过与后端的协作，我掌握了接口对接、数据格式处理和错误状态管理的技巧，能够独立完成前后端联调。
2. **团队协作能力的提升**
   - **沟通能力：** 在项目中，我与后端开发人员、产品经理和测试人员保持了密切沟通，学会了如何清晰地表达需求和问题。
   - **协作工具：** 我熟练使用了`Git`进行版本控制，以及`Jira`进行任务管理，确保了团队协作的高效性。
3. **问题解决能力的提升**
   - **性能优化：** 在商品列表页的开发中，我通过图片懒加载和代码分割技术，将页面加载时间减少了`40%`，提升了用户体验。
   - **错误处理：** 在接口对接中，我封装了统一的请求工具，处理了网络错误、超时和`401`未授权等问题，确保了系统的稳定性。
4. **项目管理和时间管理能力的提升**

- **任务拆分：** 在项目初期，我学会了如何将大任务拆分成小任务，并合理安排时间，确保按时交付。
- **优先级管理：** 在开发过程中，我能够根据需求的重要性和紧急程度，合理安排开发顺序，确保核心功能优先完成。

**实际例子**
比如，在开发购物车功能时，我遇到了商品数量更新后总价计算不准确的问题。通过分析问题、查阅文档和与后端同事沟通，我最终使用鸿蒙的状态管理工具解决了这个问题。这个过程让我深刻理解了状态管理的重要性，也提升了我的问题解决能力。



### 你觉得这个项目有什么可以改进的地方？（低）

虽然项目整体完成得不错，但我认为还有一些可以改进的地方：

1. **技术优化**
   - **性能优化：** 虽然我们已经实现了图片懒加载和代码分割，但还可以进一步优化。比如，可以考虑使用`Service Worker`实现离线缓存，或者使用`WebP`格式的图片来减少图片体积。
   - **代码质量：** 虽然我们使用了`ESLint`和`Prettier`规范代码风格，但还可以引入更多的单元测试和端到端测试，确保代码的稳定性和可维护性。
2. **用户体验优化**
   - **加载体验：** 虽然我们增加了加载动画和骨架屏，但还可以进一步优化加载体验。比如，可以使用预加载或预渲染技术，提前加载用户可能访问的页面。
   - **交互细节：** 虽然我们已经实现了一些动画效果，但还可以在交互细节上做得更好。比如，在用户点击按钮时增加微交互反馈，提升用户的参与感。
3. **团队协作**
   - **接口文档管理：** 虽然我们使用了`Swagger`生成接口文档，但文档的更新和维护还不够及时。可以考虑引入自动化文档生成工具，确保文档与代码同步更新。
   - **沟通流程：** 虽然我们定期进行沟通，但有时需求变更没有及时同步。可以引入更规范的需求变更流程，确保所有团队成员都能及时了解最新需求。
4. **项目管理**
   - **任务拆分：** 虽然我们将大任务拆分成小任务，但有时任务的优先级安排不够合理。可以引入更细致的优先级评估机制，确保核心功能优先完成。
   - **进度跟踪：** 虽然我们使用了`Jira`进行任务管理，但进度跟踪还不够细致。可以引入每日站会或每周复盘，及时发现和解决问题。
5. **实际例子**
   比如，在商品列表页的开发中，虽然我们实现了图片懒加载，但还可以进一步优化图片的加载策略。比如，可以使用`Intersection Observer API`更精确地控制图片的加载时机，或者使用`CDN`加速来提升图片的加载速度。



### 项目中遇到的坑有哪些？你是如何解决的？（低）

在项目中，我遇到了一些技术难点和`坑`，以下是两个典型的例子：

1. **图片懒加载的性能问题**
   在开发商品列表页时，我实现了图片懒加载功能，但发现页面滚动时仍然有明显的卡顿现象。
   **问题分析：**
   经过调试，我发现是因为图片加载时触发了大量的`DOM`操作，导致页面渲染性能下降。
   **解决方案：**
   - 我使用了`Intersection Observer API`来更精确地控制图片的加载时机，只有当图片进入可视区域时才加载图片。
   - 同时，我对图片进行了压缩，并使用`CDN`加速，进一步减少了图片加载时间。
   - 最终，页面滚动流畅度显著提升，用户体验得到了改善。
2. **接口数据格式不一致**
   在对接购物车功能时，我发现后端返回的数据格式与接口文档不一致，导致前端无法正确解析数据。
   **问题分析：**
   - 经过排查，我发现是因为后端开发人员在修改接口时没有及时更新文档。
     **解决方案：**
   - 我主动与后端开发人员沟通，明确了数据格式的要求，并建议使用`Swagger`自动生成接口文档，确保文档与代码同步更新。
   - 同时，我在前端代码中增加了数据格式的校验逻辑，确保即使接口返回的数据格式不一致，前端也能正确处理。
3. **状态管理问题**
   在开发购物车功能时，我遇到了商品数量更新后总价计算不准确的问题。
   **问题分析：**
   - 经过调试，我发现是因为状态更新没有及时触发，导致总价计算逻辑没有执行。
     **解决方案：**
   - 我使用了鸿蒙的`@State`和`@Watch`装饰器来管理状态，确保状态更新时能够及时触发总价计算逻辑。
   - 同时，我对购物车的数据结构进行了优化，减少了不必要的状态更新。
4. **实际例子**
   比如，在开发商品详情页时，我遇到了图片轮播组件在快速滑动时卡顿的问题。经过分析，我发现是因为图片加载和`DOM`操作过于频繁。我通过使用虚拟列表技术和图片预加载，优化了组件的性能，最终解决了卡顿问题。



### 你觉得这个项目有什么可以分享的？（低）

在这个项目中，我有以下几点可以分享：

1. **技术亮点**

   - **鸿蒙应用开发：** 通过开发用户端界面，我深入掌握了鸿蒙的ArkUI框架和`JavaScript`/`TypeScript`语言，能够熟练实现复杂的UI交互和动画效果。比如，在商品详情页中，我使用鸿蒙的自定义组件和动画库实现了图片轮播和规格选择功能，提升了用户体验。
   - **Vue3开发：** 在管理端开发中，我熟练使用了`Vue3`的`Composition API`和`Element-Plus`组件库，提升了代码的可维护性和开发效率。比如，在商品管理模块中，我使用`Vue3`的`ref`和`computed`实现了表单的动态校验功能。

2. **团队协作经验**

   - **接口对接：** 在项目中，我与后端开发人员保持了密切沟通，使用`Swagger`生成接口文档，确保前后端对接口的理解一致。比如，在开发购物车功能时，我通过接口文档和`Postman`测试工具，快速完成了接口对接。
   - **任务管理：** 我们使用`Jira`进行任务管理，将大任务拆分成小任务，并合理安排优先级，确保项目按时交付。比如，在开发订单功能时，我根据需求的重要性和紧急程度，优先完成了核心功能。

3. **问题解决经验**

   - **性能优化：** 在商品列表页的开发中，我通过图片懒加载和代码分割技术，将页面加载时间减少了`40%`，提升了用户体验。比如，我使用`Intersection Observer API`实现了图片的懒加载功能，并对图片进行了压缩和`CDN`加速。
   - **错误处理：** 在接口对接中，我封装了统一的请求工具，处理了网络错误、超时和`401`未授权等问题，确保了系统的稳定性。比如，当接口返回`401`时，前端会跳转到登录页面；当返回500时，前端会显示‘服务器错误，请稍后重试’的提示。

4. **创新点**

   - **交互优化：** 在购物车功能中，我加入了动画效果（如删除商品时的渐隐动画），提升了交互体验。比如，我使用鸿蒙的动画库实现了商品删除时的渐隐效果，让用户操作更加直观。
   - **模块化开发：** 我将通用的功能（如表单校验、请求封装）抽象成独立的模块，提升了代码的可维护性和复用性。比如，我封装了一个基于`axios`的请求工具，统一处理了接口请求和错误状态。

5. **实际例子**
   比如，在开发商品列表页时，我通过图片懒加载和代码分割技术，将页面加载时间从`X`秒减少到`Y`秒，显著提升了用户体验。这个优化过程让我深刻理解了性能优化的重要性，也让我掌握了更多的前端优化技巧。

   

### 图片懒加载实现的原理？（中）

图片懒加载是一种优化网页性能的技术，它的核心原理是延迟加载图片，只有当图片进入用户的可视区域时才加载图片，从而减少初始页面加载时间和带宽消耗。以下是图片懒加载的实现原理和具体步骤：

1. **实现原理**

   - **监听滚动事件：** 通过监听页面的滚动事件，判断图片是否进入了用户的可视区域。
   - **动态加载图片：** 当图片进入可视区域时，将图片的src属性替换为真实的图片地址，触发图片加载。

2. **技术细节**

   - **占位符：** 在图片未加载时，使用一个占位符（如1x1的透明图片或`Loading`图标）作为`src`属性，避免图片未加载时显示空白。
   - **自定义属性：** 将真实的图片地址存储在自定义属性中（如`data-src`），当需要加载图片时，将`data-src`的值赋给`src`属性。
   - **Intersection Observer API：** 现代浏览器提供了`Intersection Observer API`，可以更高效地监听元素是否进入可视区域，避免频繁触发滚动事件。

3. **实现步骤**

   **HTML结构：**

   ```html
   <img data-src="real-image.jpg" src="placeholder.jpg" alt="Lazy Load Image">
   ```

   **JavaScript逻辑：**

   - 使用`Intersection Observer API`监听图片元素。
   - 当图片进入可视区域时，将`data-src`的值赋给`src`属性，触发图片加载。

   ```js
   const images = document.querySelectorAll('img[data-src]');
   const observer = new IntersectionObserver((entries, observer) => {
   entries.forEach(entry => {
       if (entry.isIntersecting) {
       const img = entry.target;
       img.src = img.dataset.src;
       img.removeAttribute('data-src');
       observer.unobserve(img);
       }
   });
   });
   
   images.forEach(img => observer.observe(img));
   ```

4. **实际例子**
   比如，在开发商品列表页时，我使用了图片懒加载技术。初始加载时，页面只加载用户可见区域的图片，当用户滚动页面时，再动态加载其他图片。通过这种方式，页面加载时间减少了`40%`，用户体验得到了显著提升。

### 购物车实现的原理？（中）

购物车功能是电商项目的核心功能之一，它的实现原理主要包括以下几个方面：

1. **功能需求**
   购物车功能需要支持以下核心操作：

   - **添加商品：** 用户可以将商品添加到购物车。
   - **修改数量：** 用户可以修改购物车中商品的数量。
   - **删除商品：** 用户可以从购物车中删除商品。
   - **计算总价：** 实时计算购物车中商品的总价。
   - **数据同步：** 确保用户在不同设备上登录时购物车数据一致。

2. **数据结构**
   购物车的数据结构通常包括以下字段：

   - **商品ID：** 唯一标识商品。
   - **商品名称：** 商品的名称。
   - **商品价格：** 商品的单价。
   - **商品数量：** 用户选择的商品数量。
   - **商品图片：** 商品的图片`URL`。

   例如，购物车数据可以表示为：

   ```json
   [
   {
       "id": 1,
       "name": "T-shirt",
       "price": 99.9,
       "quantity": 2,
       "image": "t-shirt.jpg"
   },
   {
       "id": 2,
       "name": "Jeans",
       "price": 199.9,
       "quantity": 1,
       "image": "jeans.jpg"
   }
   ]
   ```

3. **前端实现**

   - **添加商品：** 用户点击“加入购物车”按钮时，前端将商品信息发送到后端，后端将商品添加到购物车并返回更新后的购物车数据。
   - **修改数量：** 用户修改商品数量时，前端将新的数量发送到后端，后端更新购物车数据并返回更新后的购物车数据。
   - **删除商品：** 用户删除商品时，前端将商品`ID`发送到后端，后端从购物车中删除该商品并返回更新后的购物车数据。
   - **计算总价：** 前端根据购物车数据实时计算总价，并显示给用户。

4. **后端实现**
   接口设计：

   - **获取购物车列表：** `GET /api/cart`
   - **添加商品到购物车：`POST /api/cart`
   - **修改商品数量：** `PUT /api/cart/`
   - **删除商品：** `DELETE /api/cart/`
   - **数据存储：** 购物车数据通常存储在数据库中，每个用户的购物车数据通过用户ID关联。

5. **状态管理**

   - **前端状态管理：** 在前端，可以使用状态管理工具（如`Vuex`、`Pinia`、`Redux`等）来管理购物车数据，确保数据的实时性和一致性。
   - **后端状态管理：** 在后端，购物车数据通常存储在数据库中，确保用户在不同设备上登录时购物车数据一致。

6. **实际例子**
   比如，在开发购物车功能时，我使用了`Vue3`的`Composition API`和`Pinia`来管理购物车状态。用户添加商品时，前端将商品信息发送到后端，后端将商品添加到购物车并返回更新后的购物车数据。前端根据返回的数据更新购物车状态，并实时计算总价。



### 订单实现的原理？（中）

订单功能是电商项目的核心功能之一，它的实现原理主要包括以下几个方面：

1. **功能需求**
   订单功能需要支持以下核心操作：

   - **生成订单：** 用户从购物车中选择商品并生成订单。
   - **订单支付：** 用户可以选择支付方式（如支付宝、微信支付等）完成支付。
   - **订单状态管理：** 订单状态包括待支付、已支付、已发货、已完成、已取消等。
   - **订单查询：** 用户可以查看自己的订单列表和订单详情。

2. **业务流程**
   订单的业务流程通常包括以下步骤：

   **生成订单：**

   - 用户从购物车中选择商品并提交订单。
   - 前端将商品信息和用户信息（如收货地址、支付方式等）发送到后端。
   - 后端生成订单号，并将订单信息存储到数据库中。

   **订单支付：**

   - 用户选择支付方式并完成支付。
   - 前端调用支付接口（如支付宝、微信支付等），并将支付结果发送到后端。
   - 后端更新订单状态为“已支付”。

   **订单状态管理：**

   - 后端根据业务流程更新订单状态（如已发货、已完成等）。
   - 前端通过轮询或`WebSocket`实时获取订单状态更新。

   **订单查询：**

   - 用户可以通过订单列表查看所有订单。
   - 用户可以通过订单详情查看订单的详细信息（如商品信息、支付信息、物流信息等）。

3. **数据结构**
   订单的数据结构通常包括以下字段：

   - **订单ID：** 唯一标识订单。
   - **用户ID：** 下单用户的`ID`。
   - **商品列表：** 订单中包含的商品信息（如商品`ID`、名称、价格、数量等）。
   - **订单金额：** 订单的总金额。
   - **订单状态：** 订单的当前状态（如待支付、已支付、已发货等）。
   - **收货地址：** 用户的收货地址。
   - **支付方式：** 用户选择的支付方式（如支付宝、微信支付等）。
   - **创建时间：** 订单的创建时间。

   例如，订单数据可以表示为：

   ```json
   {
   "id": "202310120001",
   "userId": 123,
   "items": [
       {
       "id": 1,
       "name": "T-shirt",
       "price": 99.9,
       "quantity": 2
       },
       {
       "id": 2,
       "name": "Jeans",
       "price": 199.9,
       "quantity": 1
       }
   ],
   "totalAmount": 399.7,
   "status": "待支付",
   "address": "北京市海淀区",
   "paymentMethod": "支付宝",
   "createdAt": "2023-10-12T10:00:00Z"
   }
   ```

4. **前后端交互**
   **生成订单：**

   - 前端发送`POST`请求到后端生成订单接口，请求体包括商品信息和用户信息。
   - 后端生成订单号，并将订单信息存储到数据库中，返回订单`ID`和支付信息。

   **订单支付：**

   - 前端调用支付接口（如支付宝、微信支付等），并将支付结果发送到后端。
   - 后端更新订单状态为“已支付”。

   **订单查询：**

   - 前端发送`GET`请求到后端订单查询接口，获取订单列表或订单详情。
   - 后端根据订单`ID`或用户`ID`查询数据库，返回订单信息。

5. **实际例子**
   比如，在开发订单功能时，我使用了`Vue3`的`Composition API`和`Pinia`来管理订单状态。用户提交订单时，前端将商品信息和用户信息发送到后端，后端生成订单号并返回支付信息。前端调用支付接口完成支付，并将支付结果发送到后端，后端更新订单状态为“已支付”。用户可以通过订单列表查看所有订单，并通过订单详情查看订单的详细信息。

### 支付实现的原理？（中）

**支付实现的核心原理**（三步流程）：

1. **发起支付请求**：
   - 用户在前端选择支付方式（如微信/支付宝），商家后端生成**订单号**和加密的支付参数（金额、描述）。
   - 调用支付平台接口（如微信/支付宝API），返回支付链接或二维码供用户授权。
2. **支付平台处理**：
   - 用户输入密码或生物验证，支付平台验证账户余额/卡状态，完成扣款。
   - 支付平台通过**异步通知**（回调）告知商家后端支付结果（需处理幂等性，避免重复入账）。
3. **完成交易**：
   - 商家后端验证通知签名和金额，更新订单状态为“已支付”，通知用户支付成功。
   - 支付平台与银行进行**资金清算**（T+1等周期），最终到账商家账户。

**关键点**：

- **安全性**：HTTPS传输、参数签名（如RSA）、防重放攻击（nonce/timestamp）。
- **异步架构**：支付结果依赖回调，需设计重试机制和对账系统。
- **幂等性**：同一订单号仅处理一次支付，避免重复扣款。

**示例流程**：
用户下单 → 商家生成订单 → 跳转支付 → 支付平台扣款 → 异步回调 → 订单状态更新 → 发货。



### 轮播实现的原理？（中）

**轮播实现的核心原理**（三步流程）：

1. **结构与布局**：
   - 容器设置 `overflow: hidden`，内部项目横向排列（如 `flex` 或 `absolute` 定位）。
   - 仅显示当前项目，其他隐藏（或通过 `transform: translateX()` 偏移）。
2. **切换逻辑**：
   - **自动播放**：通过 `setInterval` 定时移动项目位置（如修改 `index` 或 `translateX` 值）。
   - **过渡效果**：使用 CSS `transition`（如 `transform 0.5s ease`）实现平滑滑动/淡入淡出。
   - **循环处理**：克隆首尾项目，切换时快速跳转实现“无缝”衔接。
3. **交互控制**：
   - **左右箭头**：点击修改 `index`，触发切换。
   - **指示器**（小圆点）：绑定点击事件，跳转指定 `index`。
   - **触摸滑动**（移动端）：监听 `touchstart`/`touchend` 计算滑动距离，判断切换方向。

**关键优化**：

- **性能**：优先用 `transform` 代替 `left/top`，触发 GPU 加速。
- **防抖**：避免快速点击/滑动导致多次切换。
- **懒加载**：非当前项目延迟加载图片。



### 角色权限管理实现的原理？（中）

**角色权限管理核心原理**（`RBAC`模型）：

1. **三要素模型**：
   - **用户**：系统使用者。
   - **角色**：权限集合（如“管理员”“普通用户”）。
   - **权限**：具体操作或资源访问权（如“删除文章”“访问财务数据”）。
2. **关联关系**：
   - 用户绑定角色（多对多），角色分配权限（多对多）。
   - **数据库表**：用户表、角色表、权限表 + 用户-角色表、角色-权限表。
3. **权限验证**：
   - 用户访问资源时，系统根据其角色→权限链，校验是否具备操作资格（如接口注解 `@PreAuthorize("hasAuthority('delete')")`）。

**关键实现点**：

- **动态管理**：角色/权限可配置化，支持实时更新（如缓存权限数据）。
- **细粒度控制**：支持功能权限（按钮级）和数据权限（如“仅查看本部门数据”）。
- **框架集成**：结合 `Spring Security`、`Shiro` 等实现拦截与鉴权。

**示例流程**：
用户登录 → 查询角色及权限 → 缓存权限 → 访问接口 → 拦截校验权限 → 通过/拒绝。



### 你封装过哪些业务组件吗？（中）

是的，我在项目中封装过多个`Vue`业务组件，比较典型的有：

**1. 动态表单生成器**

- 基于`JSON Schema`配置自动渲染表单
- 集成校验规则（`async-validator`）
- 支持表单联动逻辑（`watch` + 动态组件）

**2. 高阶表格组件**

- 封装分页/排序/筛选逻辑
- 支持自定义列模板（作用域插槽）
- 集成`Excel`导出功能（`xlsx`库）

**3. 可视化拖拽组件**

- 基于`draggable`实现布局配置
- 维护组件树数据结构
- 实时预览与配置导出

**4. 业务弹窗管理器**

- 使用`provide/inject`实现全局调用
- 支持多弹窗堆栈管理
- 封装遮罩动画与定位逻辑



**封装时主要考虑：**

- 通过`props `/ `inject`实现配置化
- 使用插槽保证扩展性
- 采用`mixins`复用通用逻辑
- 通过`TS`类型增强提示
- 编写单元测试保证稳定性

这些组件在`3`个中后台项目中复用，减少了`30%`重复代码量。



### 说下你知道的前端UI框架？（中）

**1. 全能型（跨场景）**

- **Bootstrap**

  - 响应式栅格 + 组件库，适合快速构建 PC/移动端兼容页面
  - 经典但风格较模板化（`v5` 弃用 jQuery 依赖）

- **Ant Design**

  - React 生态标杆，企业级中后台首选（如阿里云、飞书）
  - 组件 API 设计规范，但风格偏严肃

- **Material-UI (MUI)**

  - 基于 Google Material Design，动画与交互精细

  - 支持主题深度定制（如 Figma 插件同步设计变量）

    

**2. 垂直领域**

- **Element Plus**（Vue3）

  - 后台管理系统标配，表单/表格组件功能强大
  - 中文文档友好，社区资源丰富

- **Vant**（Vue）

  - 移动端 H5 优先，支持 Rem 适配
  - 组件轻量（如电商类高频组件：地址选择器、商品卡片）

- **Quasar**

  - 支持 SSR/PWA/Electron 等多端输出

  - 内置 CLI 工具链，适合全栈型 Vue 项目

    

**3. 新兴趋势**

- **Tailwind CSS**

  - 原子化 CSS 方案，通过组合类名实现极致定制
  - 需配合构建工具（如 PostCSS），适合设计系统搭建

- **Chakra UI**（React）

  - 强调可访问性（a11y），主题配置基于 CSS-in-JS
  - 组件 API 简洁，适合快速迭代的 ToC 产品

- **Semi Design**（字节跳动）

  - Figma 设计变量联动，支持深色模式一键切换

  - 国内特色组件（如中文日期选择器）

    

**选型建议**

- **企业后台** → Ant Design / Element Plus

- **移动 H5** → Vant / MUI Mobile

- **高度定制** → Tailwind CSS + Headless UI

- **国际化产品** → MUI / Chakra UI